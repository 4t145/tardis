use crate::macro_helpers::helpers::{default_doc, ConvertVariableHelpers, TypeToTokenHelpers};
use crate::{tardis_create_entity, tardis_create_index, tardis_create_table};
use darling::FromField;
use proc_macro2::{Ident, Span, TokenStream};
use quote::{quote, ToTokens};
use std::collections::HashMap;
use syn::punctuated::Punctuated;
use syn::token::{Comma, Dot, Semi};
use syn::{Attribute, Data, Error, Fields, Result, Type};

#[derive(FromField, Debug, Clone)]
#[darling(attributes(fill_ctx))]
struct FillCtxMeta {
    ident: Option<Ident>,
    ty: Type,
    ///
    #[darling(default)]
    owner: bool,
    #[darling(default)]
    own_paths: bool,
}

pub(crate) fn create_entity(ident: Ident, data: Data, _atr: Vec<Attribute>) -> Result<TokenStream> {
    if ident != "Model" {
        panic!("Struct name must be Model");
    }
    match data.clone() {
        Data::Struct(struct_impl) => {
            let doc = default_doc();
            let create_table_stat = tardis_create_table::create_table(ident.clone(), data.clone(), _atr.clone())?;
            let create_index_stat = tardis_create_index::create_index(ident, data, _atr)?;
            // derive_relation();
            let fill_ctx_stat = create_fill_ctx_statement(struct_impl.fields)?;
            Ok(quote! {#doc
                impl TardisActiveModel for ActiveModel {
                    fn fill_ctx(&mut self, ctx: &TardisContext, is_insert: bool) {
                        if is_insert {
                            #fill_ctx_stat;
                        }
                    }

                    impl ActiveModelBehavior for ActiveModel {}

                    // Call the method automatically generated by TardisCreateTable macros
                    fn create_table_statement(db: DbBackend) -> ::tardis::db::sea_orm::sea_query::TableCreateStatement {
                        tardis_create_table_statement(db)
                    }
                    // Call the method automatically generated by TardisCreateTable macros
                    fn create_index_statement() -> Vec<::tardis::db::sea_orm::sea_query::IndexCreateStatement> {
                        tardis_create_index_statement()
                    }
                }
            #create_table_stat

            #create_index_stat

            })
        }
        Data::Enum(_) => Err(Error::new(ident.span(), "enum is not support!")),
        Data::Union(_) => Err(Error::new(ident.span(), "union is not support!")),
    }
}
fn create_fill_ctx_statement(fields: Fields) -> Result<TokenStream> {
    let mut statement: Punctuated<TokenStream, Semi> = Punctuated::new();
    for field in fields {
        for attr in field.attrs.clone() {
            if let Some(ident) = attr.path().get_ident() {
                if ident == "index" {
                    let field_fill_ctx_meta: FillCtxMeta = match FillCtxMeta::from_field(&field) {
                        Ok(field) => field,
                        Err(err) => {
                            return Ok(err.write_errors());
                        }
                    };
                    if field_fill_ctx_meta.owner {
                        if let Some(ident) = field_fill_ctx_meta.ident.clone() {
                            statement.push(quote! {
                                self.#ident=Set(ctx.owner.to_string())
                            });
                        }
                    }
                    if field_fill_ctx_meta.own_paths {
                        if let Some(ident) = field_fill_ctx_meta.ident {
                            statement.push(quote! {
                                self.#ident=Set(ctx.own_paths.to_string())
                            });
                        }
                    }
                }
            }
        }
    }
    Ok(statement.into_token_stream())
}
